// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kydroid_bridge.proto

#ifndef PROTOBUF_kydroid_5fbridge_2eproto__INCLUDED
#define PROTOBUF_kydroid_5fbridge_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace kydroid {
namespace protobuf {
namespace bridge {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_kydroid_5fbridge_2eproto();
void protobuf_AssignDesc_kydroid_5fbridge_2eproto();
void protobuf_ShutdownFile_kydroid_5fbridge_2eproto();

class StructuredError;
class Intent;
class Rect;
class Notification;
class LaunchApplication;
class SetFocusedTask;
class RemoveTask;
class ResizeTask;
class WakeupTask;
class SetPropTask;
class ClipboardData;
class BootFinishedEvent;
class WindowStateUpdateEvent;
class WindowStateUpdateEvent_WindowState;
class ApplicationListUpdateEvent;
class ApplicationListUpdateEvent_Application;
class EventSequence;

enum LaunchApplication_Stack {
  LaunchApplication_Stack_DEFAULT = 0,
  LaunchApplication_Stack_FULLSCREEN = 1,
  LaunchApplication_Stack_FREEFORM = 2
};
bool LaunchApplication_Stack_IsValid(int value);
const LaunchApplication_Stack LaunchApplication_Stack_Stack_MIN = LaunchApplication_Stack_DEFAULT;
const LaunchApplication_Stack LaunchApplication_Stack_Stack_MAX = LaunchApplication_Stack_FREEFORM;
const int LaunchApplication_Stack_Stack_ARRAYSIZE = LaunchApplication_Stack_Stack_MAX + 1;

// ===================================================================

class StructuredError : public ::google::protobuf::MessageLite {
 public:
  StructuredError();
  virtual ~StructuredError();

  StructuredError(const StructuredError& from);

  inline StructuredError& operator=(const StructuredError& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const StructuredError& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StructuredError* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StructuredError* other);

  // implements Message ----------------------------------------------

  StructuredError* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StructuredError& from);
  void MergeFrom(const StructuredError& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline ::google::protobuf::uint32 domain() const;
  inline void set_domain(::google::protobuf::uint32 value);

  // optional uint32 code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 code() const;
  inline void set_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:kydroid.protobuf.bridge.StructuredError)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_code();
  inline void clear_has_code();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 domain_;
  ::google::protobuf::uint32 code_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto();
  #endif
  friend void protobuf_AssignDesc_kydroid_5fbridge_2eproto();
  friend void protobuf_ShutdownFile_kydroid_5fbridge_2eproto();

  void InitAsDefaultInstance();
  static StructuredError* default_instance_;
};
// -------------------------------------------------------------------

class Intent : public ::google::protobuf::MessageLite {
 public:
  Intent();
  virtual ~Intent();

  Intent(const Intent& from);

  inline Intent& operator=(const Intent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Intent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Intent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Intent* other);

  // implements Message ----------------------------------------------

  Intent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Intent& from);
  void MergeFrom(const Intent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline const ::std::string& action() const;
  inline void set_action(const ::std::string& value);
  inline void set_action(const char* value);
  inline void set_action(const char* value, size_t size);
  inline ::std::string* mutable_action();
  inline ::std::string* release_action();
  inline void set_allocated_action(::std::string* action);

  // optional string uri = 2;
  inline bool has_uri() const;
  inline void clear_uri();
  static const int kUriFieldNumber = 2;
  inline const ::std::string& uri() const;
  inline void set_uri(const ::std::string& value);
  inline void set_uri(const char* value);
  inline void set_uri(const char* value, size_t size);
  inline ::std::string* mutable_uri();
  inline ::std::string* release_uri();
  inline void set_allocated_uri(::std::string* uri);

  // optional string type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string package = 4;
  inline bool has_package() const;
  inline void clear_package();
  static const int kPackageFieldNumber = 4;
  inline const ::std::string& package() const;
  inline void set_package(const ::std::string& value);
  inline void set_package(const char* value);
  inline void set_package(const char* value, size_t size);
  inline ::std::string* mutable_package();
  inline ::std::string* release_package();
  inline void set_allocated_package(::std::string* package);

  // optional string component = 5;
  inline bool has_component() const;
  inline void clear_component();
  static const int kComponentFieldNumber = 5;
  inline const ::std::string& component() const;
  inline void set_component(const ::std::string& value);
  inline void set_component(const char* value);
  inline void set_component(const char* value, size_t size);
  inline ::std::string* mutable_component();
  inline ::std::string* release_component();
  inline void set_allocated_component(::std::string* component);

  // repeated string categories = 6;
  inline int categories_size() const;
  inline void clear_categories();
  static const int kCategoriesFieldNumber = 6;
  inline const ::std::string& categories(int index) const;
  inline ::std::string* mutable_categories(int index);
  inline void set_categories(int index, const ::std::string& value);
  inline void set_categories(int index, const char* value);
  inline void set_categories(int index, const char* value, size_t size);
  inline ::std::string* add_categories();
  inline void add_categories(const ::std::string& value);
  inline void add_categories(const char* value);
  inline void add_categories(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& categories() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_categories();

  // @@protoc_insertion_point(class_scope:kydroid.protobuf.bridge.Intent)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_uri();
  inline void clear_has_uri();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_package();
  inline void clear_has_package();
  inline void set_has_component();
  inline void clear_has_component();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* action_;
  ::std::string* uri_;
  ::std::string* type_;
  ::std::string* package_;
  ::std::string* component_;
  ::google::protobuf::RepeatedPtrField< ::std::string> categories_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto();
  #endif
  friend void protobuf_AssignDesc_kydroid_5fbridge_2eproto();
  friend void protobuf_ShutdownFile_kydroid_5fbridge_2eproto();

  void InitAsDefaultInstance();
  static Intent* default_instance_;
};
// -------------------------------------------------------------------

class Rect : public ::google::protobuf::MessageLite {
 public:
  Rect();
  virtual ~Rect();

  Rect(const Rect& from);

  inline Rect& operator=(const Rect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Rect& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Rect* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Rect* other);

  // implements Message ----------------------------------------------

  Rect* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Rect& from);
  void MergeFrom(const Rect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 left = 1;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 1;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);

  // optional int32 top = 2;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 2;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);

  // optional int32 right = 3;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 3;
  inline ::google::protobuf::int32 right() const;
  inline void set_right(::google::protobuf::int32 value);

  // optional int32 bottom = 4;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 4;
  inline ::google::protobuf::int32 bottom() const;
  inline void set_bottom(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kydroid.protobuf.bridge.Rect)
 private:
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_top();
  inline void clear_has_top();
  inline void set_has_right();
  inline void clear_has_right();
  inline void set_has_bottom();
  inline void clear_has_bottom();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 bottom_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto();
  #endif
  friend void protobuf_AssignDesc_kydroid_5fbridge_2eproto();
  friend void protobuf_ShutdownFile_kydroid_5fbridge_2eproto();

  void InitAsDefaultInstance();
  static Rect* default_instance_;
};
// -------------------------------------------------------------------

class Notification : public ::google::protobuf::MessageLite {
 public:
  Notification();
  virtual ~Notification();

  Notification(const Notification& from);

  inline Notification& operator=(const Notification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Notification& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Notification* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Notification* other);

  // implements Message ----------------------------------------------

  Notification* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Notification& from);
  void MergeFrom(const Notification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string package_name = 1;
  inline bool has_package_name() const;
  inline void clear_package_name();
  static const int kPackageNameFieldNumber = 1;
  inline const ::std::string& package_name() const;
  inline void set_package_name(const ::std::string& value);
  inline void set_package_name(const char* value);
  inline void set_package_name(const char* value, size_t size);
  inline ::std::string* mutable_package_name();
  inline ::std::string* release_package_name();
  inline void set_allocated_package_name(::std::string* package_name);

  // required string category = 2;
  inline bool has_category() const;
  inline void clear_category();
  static const int kCategoryFieldNumber = 2;
  inline const ::std::string& category() const;
  inline void set_category(const ::std::string& value);
  inline void set_category(const char* value);
  inline void set_category(const char* value, size_t size);
  inline ::std::string* mutable_category();
  inline ::std::string* release_category();
  inline void set_allocated_category(::std::string* category);

  // required string title = 3;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 3;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string ticker_text = 4;
  inline bool has_ticker_text() const;
  inline void clear_ticker_text();
  static const int kTickerTextFieldNumber = 4;
  inline const ::std::string& ticker_text() const;
  inline void set_ticker_text(const ::std::string& value);
  inline void set_ticker_text(const char* value);
  inline void set_ticker_text(const char* value, size_t size);
  inline ::std::string* mutable_ticker_text();
  inline ::std::string* release_ticker_text();
  inline void set_allocated_ticker_text(::std::string* ticker_text);

  // optional string text = 5;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 5;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:kydroid.protobuf.bridge.Notification)
 private:
  inline void set_has_package_name();
  inline void clear_has_package_name();
  inline void set_has_category();
  inline void clear_has_category();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_ticker_text();
  inline void clear_has_ticker_text();
  inline void set_has_text();
  inline void clear_has_text();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* package_name_;
  ::std::string* category_;
  ::std::string* title_;
  ::std::string* ticker_text_;
  ::std::string* text_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto();
  #endif
  friend void protobuf_AssignDesc_kydroid_5fbridge_2eproto();
  friend void protobuf_ShutdownFile_kydroid_5fbridge_2eproto();

  void InitAsDefaultInstance();
  static Notification* default_instance_;
};
// -------------------------------------------------------------------

class LaunchApplication : public ::google::protobuf::MessageLite {
 public:
  LaunchApplication();
  virtual ~LaunchApplication();

  LaunchApplication(const LaunchApplication& from);

  inline LaunchApplication& operator=(const LaunchApplication& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const LaunchApplication& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LaunchApplication* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LaunchApplication* other);

  // implements Message ----------------------------------------------

  LaunchApplication* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LaunchApplication& from);
  void MergeFrom(const LaunchApplication& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef LaunchApplication_Stack Stack;
  static const Stack DEFAULT = LaunchApplication_Stack_DEFAULT;
  static const Stack FULLSCREEN = LaunchApplication_Stack_FULLSCREEN;
  static const Stack FREEFORM = LaunchApplication_Stack_FREEFORM;
  static inline bool Stack_IsValid(int value) {
    return LaunchApplication_Stack_IsValid(value);
  }
  static const Stack Stack_MIN =
    LaunchApplication_Stack_Stack_MIN;
  static const Stack Stack_MAX =
    LaunchApplication_Stack_Stack_MAX;
  static const int Stack_ARRAYSIZE =
    LaunchApplication_Stack_Stack_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .kydroid.protobuf.bridge.Intent intent = 1;
  inline bool has_intent() const;
  inline void clear_intent();
  static const int kIntentFieldNumber = 1;
  inline const ::kydroid::protobuf::bridge::Intent& intent() const;
  inline ::kydroid::protobuf::bridge::Intent* mutable_intent();
  inline ::kydroid::protobuf::bridge::Intent* release_intent();
  inline void set_allocated_intent(::kydroid::protobuf::bridge::Intent* intent);

  // optional .kydroid.protobuf.bridge.Rect launch_bounds = 2;
  inline bool has_launch_bounds() const;
  inline void clear_launch_bounds();
  static const int kLaunchBoundsFieldNumber = 2;
  inline const ::kydroid::protobuf::bridge::Rect& launch_bounds() const;
  inline ::kydroid::protobuf::bridge::Rect* mutable_launch_bounds();
  inline ::kydroid::protobuf::bridge::Rect* release_launch_bounds();
  inline void set_allocated_launch_bounds(::kydroid::protobuf::bridge::Rect* launch_bounds);

  // optional .kydroid.protobuf.bridge.LaunchApplication.Stack stack = 3 [default = DEFAULT];
  inline bool has_stack() const;
  inline void clear_stack();
  static const int kStackFieldNumber = 3;
  inline ::kydroid::protobuf::bridge::LaunchApplication_Stack stack() const;
  inline void set_stack(::kydroid::protobuf::bridge::LaunchApplication_Stack value);

  // @@protoc_insertion_point(class_scope:kydroid.protobuf.bridge.LaunchApplication)
 private:
  inline void set_has_intent();
  inline void clear_has_intent();
  inline void set_has_launch_bounds();
  inline void clear_has_launch_bounds();
  inline void set_has_stack();
  inline void clear_has_stack();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::kydroid::protobuf::bridge::Intent* intent_;
  ::kydroid::protobuf::bridge::Rect* launch_bounds_;
  int stack_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto();
  #endif
  friend void protobuf_AssignDesc_kydroid_5fbridge_2eproto();
  friend void protobuf_ShutdownFile_kydroid_5fbridge_2eproto();

  void InitAsDefaultInstance();
  static LaunchApplication* default_instance_;
};
// -------------------------------------------------------------------

class SetFocusedTask : public ::google::protobuf::MessageLite {
 public:
  SetFocusedTask();
  virtual ~SetFocusedTask();

  SetFocusedTask(const SetFocusedTask& from);

  inline SetFocusedTask& operator=(const SetFocusedTask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SetFocusedTask& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SetFocusedTask* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SetFocusedTask* other);

  // implements Message ----------------------------------------------

  SetFocusedTask* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SetFocusedTask& from);
  void MergeFrom(const SetFocusedTask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kydroid.protobuf.bridge.SetFocusedTask)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto();
  #endif
  friend void protobuf_AssignDesc_kydroid_5fbridge_2eproto();
  friend void protobuf_ShutdownFile_kydroid_5fbridge_2eproto();

  void InitAsDefaultInstance();
  static SetFocusedTask* default_instance_;
};
// -------------------------------------------------------------------

class RemoveTask : public ::google::protobuf::MessageLite {
 public:
  RemoveTask();
  virtual ~RemoveTask();

  RemoveTask(const RemoveTask& from);

  inline RemoveTask& operator=(const RemoveTask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RemoveTask& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RemoveTask* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RemoveTask* other);

  // implements Message ----------------------------------------------

  RemoveTask* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RemoveTask& from);
  void MergeFrom(const RemoveTask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kydroid.protobuf.bridge.RemoveTask)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto();
  #endif
  friend void protobuf_AssignDesc_kydroid_5fbridge_2eproto();
  friend void protobuf_ShutdownFile_kydroid_5fbridge_2eproto();

  void InitAsDefaultInstance();
  static RemoveTask* default_instance_;
};
// -------------------------------------------------------------------

class ResizeTask : public ::google::protobuf::MessageLite {
 public:
  ResizeTask();
  virtual ~ResizeTask();

  ResizeTask(const ResizeTask& from);

  inline ResizeTask& operator=(const ResizeTask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ResizeTask& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResizeTask* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResizeTask* other);

  // implements Message ----------------------------------------------

  ResizeTask* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResizeTask& from);
  void MergeFrom(const ResizeTask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 resize_mode = 2;
  inline bool has_resize_mode() const;
  inline void clear_resize_mode();
  static const int kResizeModeFieldNumber = 2;
  inline ::google::protobuf::int32 resize_mode() const;
  inline void set_resize_mode(::google::protobuf::int32 value);

  // required .kydroid.protobuf.bridge.Rect rect = 3;
  inline bool has_rect() const;
  inline void clear_rect();
  static const int kRectFieldNumber = 3;
  inline const ::kydroid::protobuf::bridge::Rect& rect() const;
  inline ::kydroid::protobuf::bridge::Rect* mutable_rect();
  inline ::kydroid::protobuf::bridge::Rect* release_rect();
  inline void set_allocated_rect(::kydroid::protobuf::bridge::Rect* rect);

  // @@protoc_insertion_point(class_scope:kydroid.protobuf.bridge.ResizeTask)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_resize_mode();
  inline void clear_has_resize_mode();
  inline void set_has_rect();
  inline void clear_has_rect();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 resize_mode_;
  ::kydroid::protobuf::bridge::Rect* rect_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto();
  #endif
  friend void protobuf_AssignDesc_kydroid_5fbridge_2eproto();
  friend void protobuf_ShutdownFile_kydroid_5fbridge_2eproto();

  void InitAsDefaultInstance();
  static ResizeTask* default_instance_;
};
// -------------------------------------------------------------------

class WakeupTask : public ::google::protobuf::MessageLite {
 public:
  WakeupTask();
  virtual ~WakeupTask();

  WakeupTask(const WakeupTask& from);

  inline WakeupTask& operator=(const WakeupTask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const WakeupTask& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WakeupTask* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WakeupTask* other);

  // implements Message ----------------------------------------------

  WakeupTask* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WakeupTask& from);
  void MergeFrom(const WakeupTask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kydroid.protobuf.bridge.WakeupTask)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto();
  #endif
  friend void protobuf_AssignDesc_kydroid_5fbridge_2eproto();
  friend void protobuf_ShutdownFile_kydroid_5fbridge_2eproto();

  void InitAsDefaultInstance();
  static WakeupTask* default_instance_;
};
// -------------------------------------------------------------------

class SetPropTask : public ::google::protobuf::MessageLite {
 public:
  SetPropTask();
  virtual ~SetPropTask();

  SetPropTask(const SetPropTask& from);

  inline SetPropTask& operator=(const SetPropTask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SetPropTask& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SetPropTask* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SetPropTask* other);

  // implements Message ----------------------------------------------

  SetPropTask* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SetPropTask& from);
  void MergeFrom(const SetPropTask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string prop_key = 1;
  inline bool has_prop_key() const;
  inline void clear_prop_key();
  static const int kPropKeyFieldNumber = 1;
  inline const ::std::string& prop_key() const;
  inline void set_prop_key(const ::std::string& value);
  inline void set_prop_key(const char* value);
  inline void set_prop_key(const char* value, size_t size);
  inline ::std::string* mutable_prop_key();
  inline ::std::string* release_prop_key();
  inline void set_allocated_prop_key(::std::string* prop_key);

  // required string prop_value = 2;
  inline bool has_prop_value() const;
  inline void clear_prop_value();
  static const int kPropValueFieldNumber = 2;
  inline const ::std::string& prop_value() const;
  inline void set_prop_value(const ::std::string& value);
  inline void set_prop_value(const char* value);
  inline void set_prop_value(const char* value, size_t size);
  inline ::std::string* mutable_prop_value();
  inline ::std::string* release_prop_value();
  inline void set_allocated_prop_value(::std::string* prop_value);

  // @@protoc_insertion_point(class_scope:kydroid.protobuf.bridge.SetPropTask)
 private:
  inline void set_has_prop_key();
  inline void clear_has_prop_key();
  inline void set_has_prop_value();
  inline void clear_has_prop_value();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* prop_key_;
  ::std::string* prop_value_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto();
  #endif
  friend void protobuf_AssignDesc_kydroid_5fbridge_2eproto();
  friend void protobuf_ShutdownFile_kydroid_5fbridge_2eproto();

  void InitAsDefaultInstance();
  static SetPropTask* default_instance_;
};
// -------------------------------------------------------------------

class ClipboardData : public ::google::protobuf::MessageLite {
 public:
  ClipboardData();
  virtual ~ClipboardData();

  ClipboardData(const ClipboardData& from);

  inline ClipboardData& operator=(const ClipboardData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ClipboardData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClipboardData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClipboardData* other);

  // implements Message ----------------------------------------------

  ClipboardData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClipboardData& from);
  void MergeFrom(const ClipboardData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional string error = 127;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 127;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  inline void set_allocated_error(::std::string* error);

  // optional .kydroid.protobuf.bridge.StructuredError structured_error = 128;
  inline bool has_structured_error() const;
  inline void clear_structured_error();
  static const int kStructuredErrorFieldNumber = 128;
  inline const ::kydroid::protobuf::bridge::StructuredError& structured_error() const;
  inline ::kydroid::protobuf::bridge::StructuredError* mutable_structured_error();
  inline ::kydroid::protobuf::bridge::StructuredError* release_structured_error();
  inline void set_allocated_structured_error(::kydroid::protobuf::bridge::StructuredError* structured_error);

  // @@protoc_insertion_point(class_scope:kydroid.protobuf.bridge.ClipboardData)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_structured_error();
  inline void clear_has_structured_error();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* text_;
  ::std::string* error_;
  ::kydroid::protobuf::bridge::StructuredError* structured_error_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto();
  #endif
  friend void protobuf_AssignDesc_kydroid_5fbridge_2eproto();
  friend void protobuf_ShutdownFile_kydroid_5fbridge_2eproto();

  void InitAsDefaultInstance();
  static ClipboardData* default_instance_;
};
// -------------------------------------------------------------------

class BootFinishedEvent : public ::google::protobuf::MessageLite {
 public:
  BootFinishedEvent();
  virtual ~BootFinishedEvent();

  BootFinishedEvent(const BootFinishedEvent& from);

  inline BootFinishedEvent& operator=(const BootFinishedEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BootFinishedEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BootFinishedEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BootFinishedEvent* other);

  // implements Message ----------------------------------------------

  BootFinishedEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BootFinishedEvent& from);
  void MergeFrom(const BootFinishedEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool first_boot_done = 1;
  inline bool has_first_boot_done() const;
  inline void clear_first_boot_done();
  static const int kFirstBootDoneFieldNumber = 1;
  inline bool first_boot_done() const;
  inline void set_first_boot_done(bool value);

  // @@protoc_insertion_point(class_scope:kydroid.protobuf.bridge.BootFinishedEvent)
 private:
  inline void set_has_first_boot_done();
  inline void clear_has_first_boot_done();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool first_boot_done_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto();
  #endif
  friend void protobuf_AssignDesc_kydroid_5fbridge_2eproto();
  friend void protobuf_ShutdownFile_kydroid_5fbridge_2eproto();

  void InitAsDefaultInstance();
  static BootFinishedEvent* default_instance_;
};
// -------------------------------------------------------------------

class WindowStateUpdateEvent_WindowState : public ::google::protobuf::MessageLite {
 public:
  WindowStateUpdateEvent_WindowState();
  virtual ~WindowStateUpdateEvent_WindowState();

  WindowStateUpdateEvent_WindowState(const WindowStateUpdateEvent_WindowState& from);

  inline WindowStateUpdateEvent_WindowState& operator=(const WindowStateUpdateEvent_WindowState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const WindowStateUpdateEvent_WindowState& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WindowStateUpdateEvent_WindowState* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WindowStateUpdateEvent_WindowState* other);

  // implements Message ----------------------------------------------

  WindowStateUpdateEvent_WindowState* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WindowStateUpdateEvent_WindowState& from);
  void MergeFrom(const WindowStateUpdateEvent_WindowState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 display_id = 1;
  inline bool has_display_id() const;
  inline void clear_display_id();
  static const int kDisplayIdFieldNumber = 1;
  inline ::google::protobuf::int32 display_id() const;
  inline void set_display_id(::google::protobuf::int32 value);

  // required bool has_surface = 2;
  inline bool has_has_surface() const;
  inline void clear_has_surface();
  static const int kHasSurfaceFieldNumber = 2;
  inline bool has_surface() const;
  inline void set_has_surface(bool value);

  // required string package_name = 3;
  inline bool has_package_name() const;
  inline void clear_package_name();
  static const int kPackageNameFieldNumber = 3;
  inline const ::std::string& package_name() const;
  inline void set_package_name(const ::std::string& value);
  inline void set_package_name(const char* value);
  inline void set_package_name(const char* value, size_t size);
  inline ::std::string* mutable_package_name();
  inline ::std::string* release_package_name();
  inline void set_allocated_package_name(::std::string* package_name);

  // required int32 frame_left = 4;
  inline bool has_frame_left() const;
  inline void clear_frame_left();
  static const int kFrameLeftFieldNumber = 4;
  inline ::google::protobuf::int32 frame_left() const;
  inline void set_frame_left(::google::protobuf::int32 value);

  // required int32 frame_top = 5;
  inline bool has_frame_top() const;
  inline void clear_frame_top();
  static const int kFrameTopFieldNumber = 5;
  inline ::google::protobuf::int32 frame_top() const;
  inline void set_frame_top(::google::protobuf::int32 value);

  // required int32 frame_right = 6;
  inline bool has_frame_right() const;
  inline void clear_frame_right();
  static const int kFrameRightFieldNumber = 6;
  inline ::google::protobuf::int32 frame_right() const;
  inline void set_frame_right(::google::protobuf::int32 value);

  // required int32 frame_bottom = 7;
  inline bool has_frame_bottom() const;
  inline void clear_frame_bottom();
  static const int kFrameBottomFieldNumber = 7;
  inline ::google::protobuf::int32 frame_bottom() const;
  inline void set_frame_bottom(::google::protobuf::int32 value);

  // required int32 task_id = 8;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 8;
  inline ::google::protobuf::int32 task_id() const;
  inline void set_task_id(::google::protobuf::int32 value);

  // required int32 stack_id = 9;
  inline bool has_stack_id() const;
  inline void clear_stack_id();
  static const int kStackIdFieldNumber = 9;
  inline ::google::protobuf::int32 stack_id() const;
  inline void set_stack_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState)
 private:
  inline void set_has_display_id();
  inline void clear_has_display_id();
  inline void set_has_has_surface();
  inline void clear_has_has_surface();
  inline void set_has_package_name();
  inline void clear_has_package_name();
  inline void set_has_frame_left();
  inline void clear_has_frame_left();
  inline void set_has_frame_top();
  inline void clear_has_frame_top();
  inline void set_has_frame_right();
  inline void clear_has_frame_right();
  inline void set_has_frame_bottom();
  inline void clear_has_frame_bottom();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_stack_id();
  inline void clear_has_stack_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 display_id_;
  bool has_surface_;
  ::std::string* package_name_;
  ::google::protobuf::int32 frame_left_;
  ::google::protobuf::int32 frame_top_;
  ::google::protobuf::int32 frame_right_;
  ::google::protobuf::int32 frame_bottom_;
  ::google::protobuf::int32 task_id_;
  ::google::protobuf::int32 stack_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto();
  #endif
  friend void protobuf_AssignDesc_kydroid_5fbridge_2eproto();
  friend void protobuf_ShutdownFile_kydroid_5fbridge_2eproto();

  void InitAsDefaultInstance();
  static WindowStateUpdateEvent_WindowState* default_instance_;
};
// -------------------------------------------------------------------

class WindowStateUpdateEvent : public ::google::protobuf::MessageLite {
 public:
  WindowStateUpdateEvent();
  virtual ~WindowStateUpdateEvent();

  WindowStateUpdateEvent(const WindowStateUpdateEvent& from);

  inline WindowStateUpdateEvent& operator=(const WindowStateUpdateEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const WindowStateUpdateEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WindowStateUpdateEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WindowStateUpdateEvent* other);

  // implements Message ----------------------------------------------

  WindowStateUpdateEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WindowStateUpdateEvent& from);
  void MergeFrom(const WindowStateUpdateEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef WindowStateUpdateEvent_WindowState WindowState;

  // accessors -------------------------------------------------------

  // repeated .kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState windows = 1;
  inline int windows_size() const;
  inline void clear_windows();
  static const int kWindowsFieldNumber = 1;
  inline const ::kydroid::protobuf::bridge::WindowStateUpdateEvent_WindowState& windows(int index) const;
  inline ::kydroid::protobuf::bridge::WindowStateUpdateEvent_WindowState* mutable_windows(int index);
  inline ::kydroid::protobuf::bridge::WindowStateUpdateEvent_WindowState* add_windows();
  inline const ::google::protobuf::RepeatedPtrField< ::kydroid::protobuf::bridge::WindowStateUpdateEvent_WindowState >&
      windows() const;
  inline ::google::protobuf::RepeatedPtrField< ::kydroid::protobuf::bridge::WindowStateUpdateEvent_WindowState >*
      mutable_windows();

  // repeated .kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState removed_windows = 2;
  inline int removed_windows_size() const;
  inline void clear_removed_windows();
  static const int kRemovedWindowsFieldNumber = 2;
  inline const ::kydroid::protobuf::bridge::WindowStateUpdateEvent_WindowState& removed_windows(int index) const;
  inline ::kydroid::protobuf::bridge::WindowStateUpdateEvent_WindowState* mutable_removed_windows(int index);
  inline ::kydroid::protobuf::bridge::WindowStateUpdateEvent_WindowState* add_removed_windows();
  inline const ::google::protobuf::RepeatedPtrField< ::kydroid::protobuf::bridge::WindowStateUpdateEvent_WindowState >&
      removed_windows() const;
  inline ::google::protobuf::RepeatedPtrField< ::kydroid::protobuf::bridge::WindowStateUpdateEvent_WindowState >*
      mutable_removed_windows();

  // @@protoc_insertion_point(class_scope:kydroid.protobuf.bridge.WindowStateUpdateEvent)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::kydroid::protobuf::bridge::WindowStateUpdateEvent_WindowState > windows_;
  ::google::protobuf::RepeatedPtrField< ::kydroid::protobuf::bridge::WindowStateUpdateEvent_WindowState > removed_windows_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto();
  #endif
  friend void protobuf_AssignDesc_kydroid_5fbridge_2eproto();
  friend void protobuf_ShutdownFile_kydroid_5fbridge_2eproto();

  void InitAsDefaultInstance();
  static WindowStateUpdateEvent* default_instance_;
};
// -------------------------------------------------------------------

class ApplicationListUpdateEvent_Application : public ::google::protobuf::MessageLite {
 public:
  ApplicationListUpdateEvent_Application();
  virtual ~ApplicationListUpdateEvent_Application();

  ApplicationListUpdateEvent_Application(const ApplicationListUpdateEvent_Application& from);

  inline ApplicationListUpdateEvent_Application& operator=(const ApplicationListUpdateEvent_Application& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ApplicationListUpdateEvent_Application& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ApplicationListUpdateEvent_Application* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ApplicationListUpdateEvent_Application* other);

  // implements Message ----------------------------------------------

  ApplicationListUpdateEvent_Application* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ApplicationListUpdateEvent_Application& from);
  void MergeFrom(const ApplicationListUpdateEvent_Application& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string package = 2;
  inline bool has_package() const;
  inline void clear_package();
  static const int kPackageFieldNumber = 2;
  inline const ::std::string& package() const;
  inline void set_package(const ::std::string& value);
  inline void set_package(const char* value);
  inline void set_package(const char* value, size_t size);
  inline ::std::string* mutable_package();
  inline ::std::string* release_package();
  inline void set_allocated_package(::std::string* package);

  // optional .kydroid.protobuf.bridge.Intent launch_intent = 3;
  inline bool has_launch_intent() const;
  inline void clear_launch_intent();
  static const int kLaunchIntentFieldNumber = 3;
  inline const ::kydroid::protobuf::bridge::Intent& launch_intent() const;
  inline ::kydroid::protobuf::bridge::Intent* mutable_launch_intent();
  inline ::kydroid::protobuf::bridge::Intent* release_launch_intent();
  inline void set_allocated_launch_intent(::kydroid::protobuf::bridge::Intent* launch_intent);

  // @@protoc_insertion_point(class_scope:kydroid.protobuf.bridge.ApplicationListUpdateEvent.Application)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_package();
  inline void clear_has_package();
  inline void set_has_launch_intent();
  inline void clear_has_launch_intent();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* package_;
  ::kydroid::protobuf::bridge::Intent* launch_intent_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto();
  #endif
  friend void protobuf_AssignDesc_kydroid_5fbridge_2eproto();
  friend void protobuf_ShutdownFile_kydroid_5fbridge_2eproto();

  void InitAsDefaultInstance();
  static ApplicationListUpdateEvent_Application* default_instance_;
};
// -------------------------------------------------------------------

class ApplicationListUpdateEvent : public ::google::protobuf::MessageLite {
 public:
  ApplicationListUpdateEvent();
  virtual ~ApplicationListUpdateEvent();

  ApplicationListUpdateEvent(const ApplicationListUpdateEvent& from);

  inline ApplicationListUpdateEvent& operator=(const ApplicationListUpdateEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ApplicationListUpdateEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ApplicationListUpdateEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ApplicationListUpdateEvent* other);

  // implements Message ----------------------------------------------

  ApplicationListUpdateEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ApplicationListUpdateEvent& from);
  void MergeFrom(const ApplicationListUpdateEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ApplicationListUpdateEvent_Application Application;

  // accessors -------------------------------------------------------

  // repeated .kydroid.protobuf.bridge.ApplicationListUpdateEvent.Application applications = 1;
  inline int applications_size() const;
  inline void clear_applications();
  static const int kApplicationsFieldNumber = 1;
  inline const ::kydroid::protobuf::bridge::ApplicationListUpdateEvent_Application& applications(int index) const;
  inline ::kydroid::protobuf::bridge::ApplicationListUpdateEvent_Application* mutable_applications(int index);
  inline ::kydroid::protobuf::bridge::ApplicationListUpdateEvent_Application* add_applications();
  inline const ::google::protobuf::RepeatedPtrField< ::kydroid::protobuf::bridge::ApplicationListUpdateEvent_Application >&
      applications() const;
  inline ::google::protobuf::RepeatedPtrField< ::kydroid::protobuf::bridge::ApplicationListUpdateEvent_Application >*
      mutable_applications();

  // repeated .kydroid.protobuf.bridge.ApplicationListUpdateEvent.Application removed_applications = 2;
  inline int removed_applications_size() const;
  inline void clear_removed_applications();
  static const int kRemovedApplicationsFieldNumber = 2;
  inline const ::kydroid::protobuf::bridge::ApplicationListUpdateEvent_Application& removed_applications(int index) const;
  inline ::kydroid::protobuf::bridge::ApplicationListUpdateEvent_Application* mutable_removed_applications(int index);
  inline ::kydroid::protobuf::bridge::ApplicationListUpdateEvent_Application* add_removed_applications();
  inline const ::google::protobuf::RepeatedPtrField< ::kydroid::protobuf::bridge::ApplicationListUpdateEvent_Application >&
      removed_applications() const;
  inline ::google::protobuf::RepeatedPtrField< ::kydroid::protobuf::bridge::ApplicationListUpdateEvent_Application >*
      mutable_removed_applications();

  // @@protoc_insertion_point(class_scope:kydroid.protobuf.bridge.ApplicationListUpdateEvent)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::kydroid::protobuf::bridge::ApplicationListUpdateEvent_Application > applications_;
  ::google::protobuf::RepeatedPtrField< ::kydroid::protobuf::bridge::ApplicationListUpdateEvent_Application > removed_applications_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto();
  #endif
  friend void protobuf_AssignDesc_kydroid_5fbridge_2eproto();
  friend void protobuf_ShutdownFile_kydroid_5fbridge_2eproto();

  void InitAsDefaultInstance();
  static ApplicationListUpdateEvent* default_instance_;
};
// -------------------------------------------------------------------

class EventSequence : public ::google::protobuf::MessageLite {
 public:
  EventSequence();
  virtual ~EventSequence();

  EventSequence(const EventSequence& from);

  inline EventSequence& operator=(const EventSequence& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const EventSequence& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EventSequence* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EventSequence* other);

  // implements Message ----------------------------------------------

  EventSequence* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EventSequence& from);
  void MergeFrom(const EventSequence& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .kydroid.protobuf.bridge.BootFinishedEvent boot_finished = 1;
  inline bool has_boot_finished() const;
  inline void clear_boot_finished();
  static const int kBootFinishedFieldNumber = 1;
  inline const ::kydroid::protobuf::bridge::BootFinishedEvent& boot_finished() const;
  inline ::kydroid::protobuf::bridge::BootFinishedEvent* mutable_boot_finished();
  inline ::kydroid::protobuf::bridge::BootFinishedEvent* release_boot_finished();
  inline void set_allocated_boot_finished(::kydroid::protobuf::bridge::BootFinishedEvent* boot_finished);

  // optional .kydroid.protobuf.bridge.WindowStateUpdateEvent window_state_update = 2;
  inline bool has_window_state_update() const;
  inline void clear_window_state_update();
  static const int kWindowStateUpdateFieldNumber = 2;
  inline const ::kydroid::protobuf::bridge::WindowStateUpdateEvent& window_state_update() const;
  inline ::kydroid::protobuf::bridge::WindowStateUpdateEvent* mutable_window_state_update();
  inline ::kydroid::protobuf::bridge::WindowStateUpdateEvent* release_window_state_update();
  inline void set_allocated_window_state_update(::kydroid::protobuf::bridge::WindowStateUpdateEvent* window_state_update);

  // optional .kydroid.protobuf.bridge.ApplicationListUpdateEvent application_list_update = 3;
  inline bool has_application_list_update() const;
  inline void clear_application_list_update();
  static const int kApplicationListUpdateFieldNumber = 3;
  inline const ::kydroid::protobuf::bridge::ApplicationListUpdateEvent& application_list_update() const;
  inline ::kydroid::protobuf::bridge::ApplicationListUpdateEvent* mutable_application_list_update();
  inline ::kydroid::protobuf::bridge::ApplicationListUpdateEvent* release_application_list_update();
  inline void set_allocated_application_list_update(::kydroid::protobuf::bridge::ApplicationListUpdateEvent* application_list_update);

  // optional string error = 127;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 127;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  inline void set_allocated_error(::std::string* error);

  // optional .kydroid.protobuf.bridge.StructuredError structured_error = 128;
  inline bool has_structured_error() const;
  inline void clear_structured_error();
  static const int kStructuredErrorFieldNumber = 128;
  inline const ::kydroid::protobuf::bridge::StructuredError& structured_error() const;
  inline ::kydroid::protobuf::bridge::StructuredError* mutable_structured_error();
  inline ::kydroid::protobuf::bridge::StructuredError* release_structured_error();
  inline void set_allocated_structured_error(::kydroid::protobuf::bridge::StructuredError* structured_error);

  // @@protoc_insertion_point(class_scope:kydroid.protobuf.bridge.EventSequence)
 private:
  inline void set_has_boot_finished();
  inline void clear_has_boot_finished();
  inline void set_has_window_state_update();
  inline void clear_has_window_state_update();
  inline void set_has_application_list_update();
  inline void clear_has_application_list_update();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_structured_error();
  inline void clear_has_structured_error();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::kydroid::protobuf::bridge::BootFinishedEvent* boot_finished_;
  ::kydroid::protobuf::bridge::WindowStateUpdateEvent* window_state_update_;
  ::kydroid::protobuf::bridge::ApplicationListUpdateEvent* application_list_update_;
  ::std::string* error_;
  ::kydroid::protobuf::bridge::StructuredError* structured_error_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_kydroid_5fbridge_2eproto();
  #endif
  friend void protobuf_AssignDesc_kydroid_5fbridge_2eproto();
  friend void protobuf_ShutdownFile_kydroid_5fbridge_2eproto();

  void InitAsDefaultInstance();
  static EventSequence* default_instance_;
};
// ===================================================================


// ===================================================================

// StructuredError

// optional uint32 domain = 1;
inline bool StructuredError::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StructuredError::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StructuredError::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StructuredError::clear_domain() {
  domain_ = 0u;
  clear_has_domain();
}
inline ::google::protobuf::uint32 StructuredError::domain() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.StructuredError.domain)
  return domain_;
}
inline void StructuredError::set_domain(::google::protobuf::uint32 value) {
  set_has_domain();
  domain_ = value;
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.StructuredError.domain)
}

// optional uint32 code = 2;
inline bool StructuredError::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StructuredError::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StructuredError::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StructuredError::clear_code() {
  code_ = 0u;
  clear_has_code();
}
inline ::google::protobuf::uint32 StructuredError::code() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.StructuredError.code)
  return code_;
}
inline void StructuredError::set_code(::google::protobuf::uint32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.StructuredError.code)
}

// -------------------------------------------------------------------

// Intent

// optional string action = 1;
inline bool Intent::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Intent::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Intent::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Intent::clear_action() {
  if (action_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    action_->clear();
  }
  clear_has_action();
}
inline const ::std::string& Intent::action() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.Intent.action)
  return *action_;
}
inline void Intent::set_action(const ::std::string& value) {
  set_has_action();
  if (action_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    action_ = new ::std::string;
  }
  action_->assign(value);
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.Intent.action)
}
inline void Intent::set_action(const char* value) {
  set_has_action();
  if (action_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    action_ = new ::std::string;
  }
  action_->assign(value);
  // @@protoc_insertion_point(field_set_char:kydroid.protobuf.bridge.Intent.action)
}
inline void Intent::set_action(const char* value, size_t size) {
  set_has_action();
  if (action_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    action_ = new ::std::string;
  }
  action_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kydroid.protobuf.bridge.Intent.action)
}
inline ::std::string* Intent::mutable_action() {
  set_has_action();
  if (action_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    action_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.Intent.action)
  return action_;
}
inline ::std::string* Intent::release_action() {
  clear_has_action();
  if (action_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = action_;
    action_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Intent::set_allocated_action(::std::string* action) {
  if (action_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete action_;
  }
  if (action) {
    set_has_action();
    action_ = action;
  } else {
    clear_has_action();
    action_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.Intent.action)
}

// optional string uri = 2;
inline bool Intent::has_uri() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Intent::set_has_uri() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Intent::clear_has_uri() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Intent::clear_uri() {
  if (uri_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uri_->clear();
  }
  clear_has_uri();
}
inline const ::std::string& Intent::uri() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.Intent.uri)
  return *uri_;
}
inline void Intent::set_uri(const ::std::string& value) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uri_ = new ::std::string;
  }
  uri_->assign(value);
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.Intent.uri)
}
inline void Intent::set_uri(const char* value) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uri_ = new ::std::string;
  }
  uri_->assign(value);
  // @@protoc_insertion_point(field_set_char:kydroid.protobuf.bridge.Intent.uri)
}
inline void Intent::set_uri(const char* value, size_t size) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uri_ = new ::std::string;
  }
  uri_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kydroid.protobuf.bridge.Intent.uri)
}
inline ::std::string* Intent::mutable_uri() {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uri_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.Intent.uri)
  return uri_;
}
inline ::std::string* Intent::release_uri() {
  clear_has_uri();
  if (uri_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = uri_;
    uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Intent::set_allocated_uri(::std::string* uri) {
  if (uri_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uri_;
  }
  if (uri) {
    set_has_uri();
    uri_ = uri;
  } else {
    clear_has_uri();
    uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.Intent.uri)
}

// optional string type = 3;
inline bool Intent::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Intent::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Intent::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Intent::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& Intent::type() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.Intent.type)
  return *type_;
}
inline void Intent::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.Intent.type)
}
inline void Intent::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:kydroid.protobuf.bridge.Intent.type)
}
inline void Intent::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kydroid.protobuf.bridge.Intent.type)
}
inline ::std::string* Intent::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.Intent.type)
  return type_;
}
inline ::std::string* Intent::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Intent::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.Intent.type)
}

// optional string package = 4;
inline bool Intent::has_package() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Intent::set_has_package() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Intent::clear_has_package() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Intent::clear_package() {
  if (package_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_->clear();
  }
  clear_has_package();
}
inline const ::std::string& Intent::package() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.Intent.package)
  return *package_;
}
inline void Intent::set_package(const ::std::string& value) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_ = new ::std::string;
  }
  package_->assign(value);
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.Intent.package)
}
inline void Intent::set_package(const char* value) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_ = new ::std::string;
  }
  package_->assign(value);
  // @@protoc_insertion_point(field_set_char:kydroid.protobuf.bridge.Intent.package)
}
inline void Intent::set_package(const char* value, size_t size) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_ = new ::std::string;
  }
  package_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kydroid.protobuf.bridge.Intent.package)
}
inline ::std::string* Intent::mutable_package() {
  set_has_package();
  if (package_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.Intent.package)
  return package_;
}
inline ::std::string* Intent::release_package() {
  clear_has_package();
  if (package_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = package_;
    package_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Intent::set_allocated_package(::std::string* package) {
  if (package_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete package_;
  }
  if (package) {
    set_has_package();
    package_ = package;
  } else {
    clear_has_package();
    package_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.Intent.package)
}

// optional string component = 5;
inline bool Intent::has_component() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Intent::set_has_component() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Intent::clear_has_component() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Intent::clear_component() {
  if (component_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    component_->clear();
  }
  clear_has_component();
}
inline const ::std::string& Intent::component() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.Intent.component)
  return *component_;
}
inline void Intent::set_component(const ::std::string& value) {
  set_has_component();
  if (component_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    component_ = new ::std::string;
  }
  component_->assign(value);
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.Intent.component)
}
inline void Intent::set_component(const char* value) {
  set_has_component();
  if (component_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    component_ = new ::std::string;
  }
  component_->assign(value);
  // @@protoc_insertion_point(field_set_char:kydroid.protobuf.bridge.Intent.component)
}
inline void Intent::set_component(const char* value, size_t size) {
  set_has_component();
  if (component_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    component_ = new ::std::string;
  }
  component_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kydroid.protobuf.bridge.Intent.component)
}
inline ::std::string* Intent::mutable_component() {
  set_has_component();
  if (component_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    component_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.Intent.component)
  return component_;
}
inline ::std::string* Intent::release_component() {
  clear_has_component();
  if (component_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = component_;
    component_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Intent::set_allocated_component(::std::string* component) {
  if (component_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete component_;
  }
  if (component) {
    set_has_component();
    component_ = component;
  } else {
    clear_has_component();
    component_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.Intent.component)
}

// repeated string categories = 6;
inline int Intent::categories_size() const {
  return categories_.size();
}
inline void Intent::clear_categories() {
  categories_.Clear();
}
inline const ::std::string& Intent::categories(int index) const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.Intent.categories)
  return categories_.Get(index);
}
inline ::std::string* Intent::mutable_categories(int index) {
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.Intent.categories)
  return categories_.Mutable(index);
}
inline void Intent::set_categories(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.Intent.categories)
  categories_.Mutable(index)->assign(value);
}
inline void Intent::set_categories(int index, const char* value) {
  categories_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kydroid.protobuf.bridge.Intent.categories)
}
inline void Intent::set_categories(int index, const char* value, size_t size) {
  categories_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kydroid.protobuf.bridge.Intent.categories)
}
inline ::std::string* Intent::add_categories() {
  return categories_.Add();
}
inline void Intent::add_categories(const ::std::string& value) {
  categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kydroid.protobuf.bridge.Intent.categories)
}
inline void Intent::add_categories(const char* value) {
  categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kydroid.protobuf.bridge.Intent.categories)
}
inline void Intent::add_categories(const char* value, size_t size) {
  categories_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kydroid.protobuf.bridge.Intent.categories)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Intent::categories() const {
  // @@protoc_insertion_point(field_list:kydroid.protobuf.bridge.Intent.categories)
  return categories_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Intent::mutable_categories() {
  // @@protoc_insertion_point(field_mutable_list:kydroid.protobuf.bridge.Intent.categories)
  return &categories_;
}

// -------------------------------------------------------------------

// Rect

// optional int32 left = 1;
inline bool Rect::has_left() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rect::set_has_left() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Rect::clear_has_left() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Rect::clear_left() {
  left_ = 0;
  clear_has_left();
}
inline ::google::protobuf::int32 Rect::left() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.Rect.left)
  return left_;
}
inline void Rect::set_left(::google::protobuf::int32 value) {
  set_has_left();
  left_ = value;
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.Rect.left)
}

// optional int32 top = 2;
inline bool Rect::has_top() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rect::set_has_top() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Rect::clear_has_top() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Rect::clear_top() {
  top_ = 0;
  clear_has_top();
}
inline ::google::protobuf::int32 Rect::top() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.Rect.top)
  return top_;
}
inline void Rect::set_top(::google::protobuf::int32 value) {
  set_has_top();
  top_ = value;
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.Rect.top)
}

// optional int32 right = 3;
inline bool Rect::has_right() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Rect::set_has_right() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Rect::clear_has_right() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Rect::clear_right() {
  right_ = 0;
  clear_has_right();
}
inline ::google::protobuf::int32 Rect::right() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.Rect.right)
  return right_;
}
inline void Rect::set_right(::google::protobuf::int32 value) {
  set_has_right();
  right_ = value;
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.Rect.right)
}

// optional int32 bottom = 4;
inline bool Rect::has_bottom() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Rect::set_has_bottom() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Rect::clear_has_bottom() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Rect::clear_bottom() {
  bottom_ = 0;
  clear_has_bottom();
}
inline ::google::protobuf::int32 Rect::bottom() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.Rect.bottom)
  return bottom_;
}
inline void Rect::set_bottom(::google::protobuf::int32 value) {
  set_has_bottom();
  bottom_ = value;
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.Rect.bottom)
}

// -------------------------------------------------------------------

// Notification

// required string package_name = 1;
inline bool Notification::has_package_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Notification::set_has_package_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Notification::clear_has_package_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Notification::clear_package_name() {
  if (package_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_name_->clear();
  }
  clear_has_package_name();
}
inline const ::std::string& Notification::package_name() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.Notification.package_name)
  return *package_name_;
}
inline void Notification::set_package_name(const ::std::string& value) {
  set_has_package_name();
  if (package_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_name_ = new ::std::string;
  }
  package_name_->assign(value);
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.Notification.package_name)
}
inline void Notification::set_package_name(const char* value) {
  set_has_package_name();
  if (package_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_name_ = new ::std::string;
  }
  package_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:kydroid.protobuf.bridge.Notification.package_name)
}
inline void Notification::set_package_name(const char* value, size_t size) {
  set_has_package_name();
  if (package_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_name_ = new ::std::string;
  }
  package_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kydroid.protobuf.bridge.Notification.package_name)
}
inline ::std::string* Notification::mutable_package_name() {
  set_has_package_name();
  if (package_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.Notification.package_name)
  return package_name_;
}
inline ::std::string* Notification::release_package_name() {
  clear_has_package_name();
  if (package_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = package_name_;
    package_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Notification::set_allocated_package_name(::std::string* package_name) {
  if (package_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete package_name_;
  }
  if (package_name) {
    set_has_package_name();
    package_name_ = package_name;
  } else {
    clear_has_package_name();
    package_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.Notification.package_name)
}

// required string category = 2;
inline bool Notification::has_category() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Notification::set_has_category() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Notification::clear_has_category() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Notification::clear_category() {
  if (category_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    category_->clear();
  }
  clear_has_category();
}
inline const ::std::string& Notification::category() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.Notification.category)
  return *category_;
}
inline void Notification::set_category(const ::std::string& value) {
  set_has_category();
  if (category_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    category_ = new ::std::string;
  }
  category_->assign(value);
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.Notification.category)
}
inline void Notification::set_category(const char* value) {
  set_has_category();
  if (category_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    category_ = new ::std::string;
  }
  category_->assign(value);
  // @@protoc_insertion_point(field_set_char:kydroid.protobuf.bridge.Notification.category)
}
inline void Notification::set_category(const char* value, size_t size) {
  set_has_category();
  if (category_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    category_ = new ::std::string;
  }
  category_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kydroid.protobuf.bridge.Notification.category)
}
inline ::std::string* Notification::mutable_category() {
  set_has_category();
  if (category_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    category_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.Notification.category)
  return category_;
}
inline ::std::string* Notification::release_category() {
  clear_has_category();
  if (category_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = category_;
    category_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Notification::set_allocated_category(::std::string* category) {
  if (category_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete category_;
  }
  if (category) {
    set_has_category();
    category_ = category;
  } else {
    clear_has_category();
    category_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.Notification.category)
}

// required string title = 3;
inline bool Notification::has_title() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Notification::set_has_title() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Notification::clear_has_title() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Notification::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& Notification::title() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.Notification.title)
  return *title_;
}
inline void Notification::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.Notification.title)
}
inline void Notification::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:kydroid.protobuf.bridge.Notification.title)
}
inline void Notification::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kydroid.protobuf.bridge.Notification.title)
}
inline ::std::string* Notification::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.Notification.title)
  return title_;
}
inline ::std::string* Notification::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Notification::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.Notification.title)
}

// optional string ticker_text = 4;
inline bool Notification::has_ticker_text() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Notification::set_has_ticker_text() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Notification::clear_has_ticker_text() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Notification::clear_ticker_text() {
  if (ticker_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ticker_text_->clear();
  }
  clear_has_ticker_text();
}
inline const ::std::string& Notification::ticker_text() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.Notification.ticker_text)
  return *ticker_text_;
}
inline void Notification::set_ticker_text(const ::std::string& value) {
  set_has_ticker_text();
  if (ticker_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ticker_text_ = new ::std::string;
  }
  ticker_text_->assign(value);
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.Notification.ticker_text)
}
inline void Notification::set_ticker_text(const char* value) {
  set_has_ticker_text();
  if (ticker_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ticker_text_ = new ::std::string;
  }
  ticker_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:kydroid.protobuf.bridge.Notification.ticker_text)
}
inline void Notification::set_ticker_text(const char* value, size_t size) {
  set_has_ticker_text();
  if (ticker_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ticker_text_ = new ::std::string;
  }
  ticker_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kydroid.protobuf.bridge.Notification.ticker_text)
}
inline ::std::string* Notification::mutable_ticker_text() {
  set_has_ticker_text();
  if (ticker_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ticker_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.Notification.ticker_text)
  return ticker_text_;
}
inline ::std::string* Notification::release_ticker_text() {
  clear_has_ticker_text();
  if (ticker_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ticker_text_;
    ticker_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Notification::set_allocated_ticker_text(::std::string* ticker_text) {
  if (ticker_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ticker_text_;
  }
  if (ticker_text) {
    set_has_ticker_text();
    ticker_text_ = ticker_text;
  } else {
    clear_has_ticker_text();
    ticker_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.Notification.ticker_text)
}

// optional string text = 5;
inline bool Notification::has_text() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Notification::set_has_text() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Notification::clear_has_text() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Notification::clear_text() {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& Notification::text() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.Notification.text)
  return *text_;
}
inline void Notification::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.Notification.text)
}
inline void Notification::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set_char:kydroid.protobuf.bridge.Notification.text)
}
inline void Notification::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kydroid.protobuf.bridge.Notification.text)
}
inline ::std::string* Notification::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.Notification.text)
  return text_;
}
inline ::std::string* Notification::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Notification::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.Notification.text)
}

// -------------------------------------------------------------------

// LaunchApplication

// required .kydroid.protobuf.bridge.Intent intent = 1;
inline bool LaunchApplication::has_intent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaunchApplication::set_has_intent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaunchApplication::clear_has_intent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaunchApplication::clear_intent() {
  if (intent_ != NULL) intent_->::kydroid::protobuf::bridge::Intent::Clear();
  clear_has_intent();
}
inline const ::kydroid::protobuf::bridge::Intent& LaunchApplication::intent() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.LaunchApplication.intent)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return intent_ != NULL ? *intent_ : *default_instance().intent_;
#else
  return intent_ != NULL ? *intent_ : *default_instance_->intent_;
#endif
}
inline ::kydroid::protobuf::bridge::Intent* LaunchApplication::mutable_intent() {
  set_has_intent();
  if (intent_ == NULL) intent_ = new ::kydroid::protobuf::bridge::Intent;
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.LaunchApplication.intent)
  return intent_;
}
inline ::kydroid::protobuf::bridge::Intent* LaunchApplication::release_intent() {
  clear_has_intent();
  ::kydroid::protobuf::bridge::Intent* temp = intent_;
  intent_ = NULL;
  return temp;
}
inline void LaunchApplication::set_allocated_intent(::kydroid::protobuf::bridge::Intent* intent) {
  delete intent_;
  intent_ = intent;
  if (intent) {
    set_has_intent();
  } else {
    clear_has_intent();
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.LaunchApplication.intent)
}

// optional .kydroid.protobuf.bridge.Rect launch_bounds = 2;
inline bool LaunchApplication::has_launch_bounds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaunchApplication::set_has_launch_bounds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaunchApplication::clear_has_launch_bounds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaunchApplication::clear_launch_bounds() {
  if (launch_bounds_ != NULL) launch_bounds_->::kydroid::protobuf::bridge::Rect::Clear();
  clear_has_launch_bounds();
}
inline const ::kydroid::protobuf::bridge::Rect& LaunchApplication::launch_bounds() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.LaunchApplication.launch_bounds)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return launch_bounds_ != NULL ? *launch_bounds_ : *default_instance().launch_bounds_;
#else
  return launch_bounds_ != NULL ? *launch_bounds_ : *default_instance_->launch_bounds_;
#endif
}
inline ::kydroid::protobuf::bridge::Rect* LaunchApplication::mutable_launch_bounds() {
  set_has_launch_bounds();
  if (launch_bounds_ == NULL) launch_bounds_ = new ::kydroid::protobuf::bridge::Rect;
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.LaunchApplication.launch_bounds)
  return launch_bounds_;
}
inline ::kydroid::protobuf::bridge::Rect* LaunchApplication::release_launch_bounds() {
  clear_has_launch_bounds();
  ::kydroid::protobuf::bridge::Rect* temp = launch_bounds_;
  launch_bounds_ = NULL;
  return temp;
}
inline void LaunchApplication::set_allocated_launch_bounds(::kydroid::protobuf::bridge::Rect* launch_bounds) {
  delete launch_bounds_;
  launch_bounds_ = launch_bounds;
  if (launch_bounds) {
    set_has_launch_bounds();
  } else {
    clear_has_launch_bounds();
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.LaunchApplication.launch_bounds)
}

// optional .kydroid.protobuf.bridge.LaunchApplication.Stack stack = 3 [default = DEFAULT];
inline bool LaunchApplication::has_stack() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaunchApplication::set_has_stack() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LaunchApplication::clear_has_stack() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LaunchApplication::clear_stack() {
  stack_ = 0;
  clear_has_stack();
}
inline ::kydroid::protobuf::bridge::LaunchApplication_Stack LaunchApplication::stack() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.LaunchApplication.stack)
  return static_cast< ::kydroid::protobuf::bridge::LaunchApplication_Stack >(stack_);
}
inline void LaunchApplication::set_stack(::kydroid::protobuf::bridge::LaunchApplication_Stack value) {
  assert(::kydroid::protobuf::bridge::LaunchApplication_Stack_IsValid(value));
  set_has_stack();
  stack_ = value;
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.LaunchApplication.stack)
}

// -------------------------------------------------------------------

// SetFocusedTask

// required int32 id = 1;
inline bool SetFocusedTask::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetFocusedTask::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetFocusedTask::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetFocusedTask::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 SetFocusedTask::id() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.SetFocusedTask.id)
  return id_;
}
inline void SetFocusedTask::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.SetFocusedTask.id)
}

// -------------------------------------------------------------------

// RemoveTask

// required int32 id = 1;
inline bool RemoveTask::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveTask::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveTask::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveTask::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RemoveTask::id() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.RemoveTask.id)
  return id_;
}
inline void RemoveTask::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.RemoveTask.id)
}

// -------------------------------------------------------------------

// ResizeTask

// required int32 id = 1;
inline bool ResizeTask::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResizeTask::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResizeTask::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResizeTask::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ResizeTask::id() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.ResizeTask.id)
  return id_;
}
inline void ResizeTask::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.ResizeTask.id)
}

// required int32 resize_mode = 2;
inline bool ResizeTask::has_resize_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResizeTask::set_has_resize_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResizeTask::clear_has_resize_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResizeTask::clear_resize_mode() {
  resize_mode_ = 0;
  clear_has_resize_mode();
}
inline ::google::protobuf::int32 ResizeTask::resize_mode() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.ResizeTask.resize_mode)
  return resize_mode_;
}
inline void ResizeTask::set_resize_mode(::google::protobuf::int32 value) {
  set_has_resize_mode();
  resize_mode_ = value;
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.ResizeTask.resize_mode)
}

// required .kydroid.protobuf.bridge.Rect rect = 3;
inline bool ResizeTask::has_rect() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResizeTask::set_has_rect() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResizeTask::clear_has_rect() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResizeTask::clear_rect() {
  if (rect_ != NULL) rect_->::kydroid::protobuf::bridge::Rect::Clear();
  clear_has_rect();
}
inline const ::kydroid::protobuf::bridge::Rect& ResizeTask::rect() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.ResizeTask.rect)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return rect_ != NULL ? *rect_ : *default_instance().rect_;
#else
  return rect_ != NULL ? *rect_ : *default_instance_->rect_;
#endif
}
inline ::kydroid::protobuf::bridge::Rect* ResizeTask::mutable_rect() {
  set_has_rect();
  if (rect_ == NULL) rect_ = new ::kydroid::protobuf::bridge::Rect;
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.ResizeTask.rect)
  return rect_;
}
inline ::kydroid::protobuf::bridge::Rect* ResizeTask::release_rect() {
  clear_has_rect();
  ::kydroid::protobuf::bridge::Rect* temp = rect_;
  rect_ = NULL;
  return temp;
}
inline void ResizeTask::set_allocated_rect(::kydroid::protobuf::bridge::Rect* rect) {
  delete rect_;
  rect_ = rect;
  if (rect) {
    set_has_rect();
  } else {
    clear_has_rect();
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.ResizeTask.rect)
}

// -------------------------------------------------------------------

// WakeupTask

// required int32 id = 1;
inline bool WakeupTask::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WakeupTask::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WakeupTask::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WakeupTask::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 WakeupTask::id() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.WakeupTask.id)
  return id_;
}
inline void WakeupTask::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.WakeupTask.id)
}

// -------------------------------------------------------------------

// SetPropTask

// required string prop_key = 1;
inline bool SetPropTask::has_prop_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetPropTask::set_has_prop_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetPropTask::clear_has_prop_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetPropTask::clear_prop_key() {
  if (prop_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prop_key_->clear();
  }
  clear_has_prop_key();
}
inline const ::std::string& SetPropTask::prop_key() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.SetPropTask.prop_key)
  return *prop_key_;
}
inline void SetPropTask::set_prop_key(const ::std::string& value) {
  set_has_prop_key();
  if (prop_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prop_key_ = new ::std::string;
  }
  prop_key_->assign(value);
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.SetPropTask.prop_key)
}
inline void SetPropTask::set_prop_key(const char* value) {
  set_has_prop_key();
  if (prop_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prop_key_ = new ::std::string;
  }
  prop_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:kydroid.protobuf.bridge.SetPropTask.prop_key)
}
inline void SetPropTask::set_prop_key(const char* value, size_t size) {
  set_has_prop_key();
  if (prop_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prop_key_ = new ::std::string;
  }
  prop_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kydroid.protobuf.bridge.SetPropTask.prop_key)
}
inline ::std::string* SetPropTask::mutable_prop_key() {
  set_has_prop_key();
  if (prop_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prop_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.SetPropTask.prop_key)
  return prop_key_;
}
inline ::std::string* SetPropTask::release_prop_key() {
  clear_has_prop_key();
  if (prop_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = prop_key_;
    prop_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SetPropTask::set_allocated_prop_key(::std::string* prop_key) {
  if (prop_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete prop_key_;
  }
  if (prop_key) {
    set_has_prop_key();
    prop_key_ = prop_key;
  } else {
    clear_has_prop_key();
    prop_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.SetPropTask.prop_key)
}

// required string prop_value = 2;
inline bool SetPropTask::has_prop_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetPropTask::set_has_prop_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetPropTask::clear_has_prop_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetPropTask::clear_prop_value() {
  if (prop_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prop_value_->clear();
  }
  clear_has_prop_value();
}
inline const ::std::string& SetPropTask::prop_value() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.SetPropTask.prop_value)
  return *prop_value_;
}
inline void SetPropTask::set_prop_value(const ::std::string& value) {
  set_has_prop_value();
  if (prop_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prop_value_ = new ::std::string;
  }
  prop_value_->assign(value);
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.SetPropTask.prop_value)
}
inline void SetPropTask::set_prop_value(const char* value) {
  set_has_prop_value();
  if (prop_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prop_value_ = new ::std::string;
  }
  prop_value_->assign(value);
  // @@protoc_insertion_point(field_set_char:kydroid.protobuf.bridge.SetPropTask.prop_value)
}
inline void SetPropTask::set_prop_value(const char* value, size_t size) {
  set_has_prop_value();
  if (prop_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prop_value_ = new ::std::string;
  }
  prop_value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kydroid.protobuf.bridge.SetPropTask.prop_value)
}
inline ::std::string* SetPropTask::mutable_prop_value() {
  set_has_prop_value();
  if (prop_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prop_value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.SetPropTask.prop_value)
  return prop_value_;
}
inline ::std::string* SetPropTask::release_prop_value() {
  clear_has_prop_value();
  if (prop_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = prop_value_;
    prop_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SetPropTask::set_allocated_prop_value(::std::string* prop_value) {
  if (prop_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete prop_value_;
  }
  if (prop_value) {
    set_has_prop_value();
    prop_value_ = prop_value;
  } else {
    clear_has_prop_value();
    prop_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.SetPropTask.prop_value)
}

// -------------------------------------------------------------------

// ClipboardData

// optional string text = 1;
inline bool ClipboardData::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClipboardData::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClipboardData::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClipboardData::clear_text() {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& ClipboardData::text() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.ClipboardData.text)
  return *text_;
}
inline void ClipboardData::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.ClipboardData.text)
}
inline void ClipboardData::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set_char:kydroid.protobuf.bridge.ClipboardData.text)
}
inline void ClipboardData::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kydroid.protobuf.bridge.ClipboardData.text)
}
inline ::std::string* ClipboardData::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.ClipboardData.text)
  return text_;
}
inline ::std::string* ClipboardData::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClipboardData::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.ClipboardData.text)
}

// optional string error = 127;
inline bool ClipboardData::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClipboardData::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClipboardData::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClipboardData::clear_error() {
  if (error_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& ClipboardData::error() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.ClipboardData.error)
  return *error_;
}
inline void ClipboardData::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(value);
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.ClipboardData.error)
}
inline void ClipboardData::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(value);
  // @@protoc_insertion_point(field_set_char:kydroid.protobuf.bridge.ClipboardData.error)
}
inline void ClipboardData::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kydroid.protobuf.bridge.ClipboardData.error)
}
inline ::std::string* ClipboardData::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.ClipboardData.error)
  return error_;
}
inline ::std::string* ClipboardData::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClipboardData::set_allocated_error(::std::string* error) {
  if (error_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete error_;
  }
  if (error) {
    set_has_error();
    error_ = error;
  } else {
    clear_has_error();
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.ClipboardData.error)
}

// optional .kydroid.protobuf.bridge.StructuredError structured_error = 128;
inline bool ClipboardData::has_structured_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClipboardData::set_has_structured_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClipboardData::clear_has_structured_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClipboardData::clear_structured_error() {
  if (structured_error_ != NULL) structured_error_->::kydroid::protobuf::bridge::StructuredError::Clear();
  clear_has_structured_error();
}
inline const ::kydroid::protobuf::bridge::StructuredError& ClipboardData::structured_error() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.ClipboardData.structured_error)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return structured_error_ != NULL ? *structured_error_ : *default_instance().structured_error_;
#else
  return structured_error_ != NULL ? *structured_error_ : *default_instance_->structured_error_;
#endif
}
inline ::kydroid::protobuf::bridge::StructuredError* ClipboardData::mutable_structured_error() {
  set_has_structured_error();
  if (structured_error_ == NULL) structured_error_ = new ::kydroid::protobuf::bridge::StructuredError;
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.ClipboardData.structured_error)
  return structured_error_;
}
inline ::kydroid::protobuf::bridge::StructuredError* ClipboardData::release_structured_error() {
  clear_has_structured_error();
  ::kydroid::protobuf::bridge::StructuredError* temp = structured_error_;
  structured_error_ = NULL;
  return temp;
}
inline void ClipboardData::set_allocated_structured_error(::kydroid::protobuf::bridge::StructuredError* structured_error) {
  delete structured_error_;
  structured_error_ = structured_error;
  if (structured_error) {
    set_has_structured_error();
  } else {
    clear_has_structured_error();
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.ClipboardData.structured_error)
}

// -------------------------------------------------------------------

// BootFinishedEvent

// optional bool first_boot_done = 1;
inline bool BootFinishedEvent::has_first_boot_done() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BootFinishedEvent::set_has_first_boot_done() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BootFinishedEvent::clear_has_first_boot_done() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BootFinishedEvent::clear_first_boot_done() {
  first_boot_done_ = false;
  clear_has_first_boot_done();
}
inline bool BootFinishedEvent::first_boot_done() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.BootFinishedEvent.first_boot_done)
  return first_boot_done_;
}
inline void BootFinishedEvent::set_first_boot_done(bool value) {
  set_has_first_boot_done();
  first_boot_done_ = value;
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.BootFinishedEvent.first_boot_done)
}

// -------------------------------------------------------------------

// WindowStateUpdateEvent_WindowState

// required int32 display_id = 1;
inline bool WindowStateUpdateEvent_WindowState::has_display_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WindowStateUpdateEvent_WindowState::set_has_display_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WindowStateUpdateEvent_WindowState::clear_has_display_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WindowStateUpdateEvent_WindowState::clear_display_id() {
  display_id_ = 0;
  clear_has_display_id();
}
inline ::google::protobuf::int32 WindowStateUpdateEvent_WindowState::display_id() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState.display_id)
  return display_id_;
}
inline void WindowStateUpdateEvent_WindowState::set_display_id(::google::protobuf::int32 value) {
  set_has_display_id();
  display_id_ = value;
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState.display_id)
}

// required bool has_surface = 2;
inline bool WindowStateUpdateEvent_WindowState::has_has_surface() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WindowStateUpdateEvent_WindowState::set_has_has_surface() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WindowStateUpdateEvent_WindowState::clear_has_has_surface() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WindowStateUpdateEvent_WindowState::clear_has_surface() {
  has_surface_ = false;
  clear_has_has_surface();
}
inline bool WindowStateUpdateEvent_WindowState::has_surface() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState.has_surface)
  return has_surface_;
}
inline void WindowStateUpdateEvent_WindowState::set_has_surface(bool value) {
  set_has_has_surface();
  has_surface_ = value;
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState.has_surface)
}

// required string package_name = 3;
inline bool WindowStateUpdateEvent_WindowState::has_package_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WindowStateUpdateEvent_WindowState::set_has_package_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WindowStateUpdateEvent_WindowState::clear_has_package_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WindowStateUpdateEvent_WindowState::clear_package_name() {
  if (package_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_name_->clear();
  }
  clear_has_package_name();
}
inline const ::std::string& WindowStateUpdateEvent_WindowState::package_name() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState.package_name)
  return *package_name_;
}
inline void WindowStateUpdateEvent_WindowState::set_package_name(const ::std::string& value) {
  set_has_package_name();
  if (package_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_name_ = new ::std::string;
  }
  package_name_->assign(value);
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState.package_name)
}
inline void WindowStateUpdateEvent_WindowState::set_package_name(const char* value) {
  set_has_package_name();
  if (package_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_name_ = new ::std::string;
  }
  package_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState.package_name)
}
inline void WindowStateUpdateEvent_WindowState::set_package_name(const char* value, size_t size) {
  set_has_package_name();
  if (package_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_name_ = new ::std::string;
  }
  package_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState.package_name)
}
inline ::std::string* WindowStateUpdateEvent_WindowState::mutable_package_name() {
  set_has_package_name();
  if (package_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState.package_name)
  return package_name_;
}
inline ::std::string* WindowStateUpdateEvent_WindowState::release_package_name() {
  clear_has_package_name();
  if (package_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = package_name_;
    package_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WindowStateUpdateEvent_WindowState::set_allocated_package_name(::std::string* package_name) {
  if (package_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete package_name_;
  }
  if (package_name) {
    set_has_package_name();
    package_name_ = package_name;
  } else {
    clear_has_package_name();
    package_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState.package_name)
}

// required int32 frame_left = 4;
inline bool WindowStateUpdateEvent_WindowState::has_frame_left() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WindowStateUpdateEvent_WindowState::set_has_frame_left() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WindowStateUpdateEvent_WindowState::clear_has_frame_left() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WindowStateUpdateEvent_WindowState::clear_frame_left() {
  frame_left_ = 0;
  clear_has_frame_left();
}
inline ::google::protobuf::int32 WindowStateUpdateEvent_WindowState::frame_left() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState.frame_left)
  return frame_left_;
}
inline void WindowStateUpdateEvent_WindowState::set_frame_left(::google::protobuf::int32 value) {
  set_has_frame_left();
  frame_left_ = value;
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState.frame_left)
}

// required int32 frame_top = 5;
inline bool WindowStateUpdateEvent_WindowState::has_frame_top() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WindowStateUpdateEvent_WindowState::set_has_frame_top() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WindowStateUpdateEvent_WindowState::clear_has_frame_top() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WindowStateUpdateEvent_WindowState::clear_frame_top() {
  frame_top_ = 0;
  clear_has_frame_top();
}
inline ::google::protobuf::int32 WindowStateUpdateEvent_WindowState::frame_top() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState.frame_top)
  return frame_top_;
}
inline void WindowStateUpdateEvent_WindowState::set_frame_top(::google::protobuf::int32 value) {
  set_has_frame_top();
  frame_top_ = value;
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState.frame_top)
}

// required int32 frame_right = 6;
inline bool WindowStateUpdateEvent_WindowState::has_frame_right() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WindowStateUpdateEvent_WindowState::set_has_frame_right() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WindowStateUpdateEvent_WindowState::clear_has_frame_right() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WindowStateUpdateEvent_WindowState::clear_frame_right() {
  frame_right_ = 0;
  clear_has_frame_right();
}
inline ::google::protobuf::int32 WindowStateUpdateEvent_WindowState::frame_right() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState.frame_right)
  return frame_right_;
}
inline void WindowStateUpdateEvent_WindowState::set_frame_right(::google::protobuf::int32 value) {
  set_has_frame_right();
  frame_right_ = value;
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState.frame_right)
}

// required int32 frame_bottom = 7;
inline bool WindowStateUpdateEvent_WindowState::has_frame_bottom() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WindowStateUpdateEvent_WindowState::set_has_frame_bottom() {
  _has_bits_[0] |= 0x00000040u;
}
inline void WindowStateUpdateEvent_WindowState::clear_has_frame_bottom() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void WindowStateUpdateEvent_WindowState::clear_frame_bottom() {
  frame_bottom_ = 0;
  clear_has_frame_bottom();
}
inline ::google::protobuf::int32 WindowStateUpdateEvent_WindowState::frame_bottom() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState.frame_bottom)
  return frame_bottom_;
}
inline void WindowStateUpdateEvent_WindowState::set_frame_bottom(::google::protobuf::int32 value) {
  set_has_frame_bottom();
  frame_bottom_ = value;
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState.frame_bottom)
}

// required int32 task_id = 8;
inline bool WindowStateUpdateEvent_WindowState::has_task_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void WindowStateUpdateEvent_WindowState::set_has_task_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void WindowStateUpdateEvent_WindowState::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void WindowStateUpdateEvent_WindowState::clear_task_id() {
  task_id_ = 0;
  clear_has_task_id();
}
inline ::google::protobuf::int32 WindowStateUpdateEvent_WindowState::task_id() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState.task_id)
  return task_id_;
}
inline void WindowStateUpdateEvent_WindowState::set_task_id(::google::protobuf::int32 value) {
  set_has_task_id();
  task_id_ = value;
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState.task_id)
}

// required int32 stack_id = 9;
inline bool WindowStateUpdateEvent_WindowState::has_stack_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void WindowStateUpdateEvent_WindowState::set_has_stack_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void WindowStateUpdateEvent_WindowState::clear_has_stack_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void WindowStateUpdateEvent_WindowState::clear_stack_id() {
  stack_id_ = 0;
  clear_has_stack_id();
}
inline ::google::protobuf::int32 WindowStateUpdateEvent_WindowState::stack_id() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState.stack_id)
  return stack_id_;
}
inline void WindowStateUpdateEvent_WindowState::set_stack_id(::google::protobuf::int32 value) {
  set_has_stack_id();
  stack_id_ = value;
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState.stack_id)
}

// -------------------------------------------------------------------

// WindowStateUpdateEvent

// repeated .kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState windows = 1;
inline int WindowStateUpdateEvent::windows_size() const {
  return windows_.size();
}
inline void WindowStateUpdateEvent::clear_windows() {
  windows_.Clear();
}
inline const ::kydroid::protobuf::bridge::WindowStateUpdateEvent_WindowState& WindowStateUpdateEvent::windows(int index) const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.WindowStateUpdateEvent.windows)
  return windows_.Get(index);
}
inline ::kydroid::protobuf::bridge::WindowStateUpdateEvent_WindowState* WindowStateUpdateEvent::mutable_windows(int index) {
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.WindowStateUpdateEvent.windows)
  return windows_.Mutable(index);
}
inline ::kydroid::protobuf::bridge::WindowStateUpdateEvent_WindowState* WindowStateUpdateEvent::add_windows() {
  // @@protoc_insertion_point(field_add:kydroid.protobuf.bridge.WindowStateUpdateEvent.windows)
  return windows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kydroid::protobuf::bridge::WindowStateUpdateEvent_WindowState >&
WindowStateUpdateEvent::windows() const {
  // @@protoc_insertion_point(field_list:kydroid.protobuf.bridge.WindowStateUpdateEvent.windows)
  return windows_;
}
inline ::google::protobuf::RepeatedPtrField< ::kydroid::protobuf::bridge::WindowStateUpdateEvent_WindowState >*
WindowStateUpdateEvent::mutable_windows() {
  // @@protoc_insertion_point(field_mutable_list:kydroid.protobuf.bridge.WindowStateUpdateEvent.windows)
  return &windows_;
}

// repeated .kydroid.protobuf.bridge.WindowStateUpdateEvent.WindowState removed_windows = 2;
inline int WindowStateUpdateEvent::removed_windows_size() const {
  return removed_windows_.size();
}
inline void WindowStateUpdateEvent::clear_removed_windows() {
  removed_windows_.Clear();
}
inline const ::kydroid::protobuf::bridge::WindowStateUpdateEvent_WindowState& WindowStateUpdateEvent::removed_windows(int index) const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.WindowStateUpdateEvent.removed_windows)
  return removed_windows_.Get(index);
}
inline ::kydroid::protobuf::bridge::WindowStateUpdateEvent_WindowState* WindowStateUpdateEvent::mutable_removed_windows(int index) {
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.WindowStateUpdateEvent.removed_windows)
  return removed_windows_.Mutable(index);
}
inline ::kydroid::protobuf::bridge::WindowStateUpdateEvent_WindowState* WindowStateUpdateEvent::add_removed_windows() {
  // @@protoc_insertion_point(field_add:kydroid.protobuf.bridge.WindowStateUpdateEvent.removed_windows)
  return removed_windows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kydroid::protobuf::bridge::WindowStateUpdateEvent_WindowState >&
WindowStateUpdateEvent::removed_windows() const {
  // @@protoc_insertion_point(field_list:kydroid.protobuf.bridge.WindowStateUpdateEvent.removed_windows)
  return removed_windows_;
}
inline ::google::protobuf::RepeatedPtrField< ::kydroid::protobuf::bridge::WindowStateUpdateEvent_WindowState >*
WindowStateUpdateEvent::mutable_removed_windows() {
  // @@protoc_insertion_point(field_mutable_list:kydroid.protobuf.bridge.WindowStateUpdateEvent.removed_windows)
  return &removed_windows_;
}

// -------------------------------------------------------------------

// ApplicationListUpdateEvent_Application

// required string name = 1;
inline bool ApplicationListUpdateEvent_Application::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplicationListUpdateEvent_Application::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplicationListUpdateEvent_Application::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplicationListUpdateEvent_Application::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ApplicationListUpdateEvent_Application::name() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.ApplicationListUpdateEvent.Application.name)
  return *name_;
}
inline void ApplicationListUpdateEvent_Application::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.ApplicationListUpdateEvent.Application.name)
}
inline void ApplicationListUpdateEvent_Application::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:kydroid.protobuf.bridge.ApplicationListUpdateEvent.Application.name)
}
inline void ApplicationListUpdateEvent_Application::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kydroid.protobuf.bridge.ApplicationListUpdateEvent.Application.name)
}
inline ::std::string* ApplicationListUpdateEvent_Application::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.ApplicationListUpdateEvent.Application.name)
  return name_;
}
inline ::std::string* ApplicationListUpdateEvent_Application::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ApplicationListUpdateEvent_Application::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.ApplicationListUpdateEvent.Application.name)
}

// required string package = 2;
inline bool ApplicationListUpdateEvent_Application::has_package() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplicationListUpdateEvent_Application::set_has_package() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplicationListUpdateEvent_Application::clear_has_package() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplicationListUpdateEvent_Application::clear_package() {
  if (package_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_->clear();
  }
  clear_has_package();
}
inline const ::std::string& ApplicationListUpdateEvent_Application::package() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.ApplicationListUpdateEvent.Application.package)
  return *package_;
}
inline void ApplicationListUpdateEvent_Application::set_package(const ::std::string& value) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_ = new ::std::string;
  }
  package_->assign(value);
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.ApplicationListUpdateEvent.Application.package)
}
inline void ApplicationListUpdateEvent_Application::set_package(const char* value) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_ = new ::std::string;
  }
  package_->assign(value);
  // @@protoc_insertion_point(field_set_char:kydroid.protobuf.bridge.ApplicationListUpdateEvent.Application.package)
}
inline void ApplicationListUpdateEvent_Application::set_package(const char* value, size_t size) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_ = new ::std::string;
  }
  package_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kydroid.protobuf.bridge.ApplicationListUpdateEvent.Application.package)
}
inline ::std::string* ApplicationListUpdateEvent_Application::mutable_package() {
  set_has_package();
  if (package_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.ApplicationListUpdateEvent.Application.package)
  return package_;
}
inline ::std::string* ApplicationListUpdateEvent_Application::release_package() {
  clear_has_package();
  if (package_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = package_;
    package_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ApplicationListUpdateEvent_Application::set_allocated_package(::std::string* package) {
  if (package_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete package_;
  }
  if (package) {
    set_has_package();
    package_ = package;
  } else {
    clear_has_package();
    package_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.ApplicationListUpdateEvent.Application.package)
}

// optional .kydroid.protobuf.bridge.Intent launch_intent = 3;
inline bool ApplicationListUpdateEvent_Application::has_launch_intent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApplicationListUpdateEvent_Application::set_has_launch_intent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ApplicationListUpdateEvent_Application::clear_has_launch_intent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ApplicationListUpdateEvent_Application::clear_launch_intent() {
  if (launch_intent_ != NULL) launch_intent_->::kydroid::protobuf::bridge::Intent::Clear();
  clear_has_launch_intent();
}
inline const ::kydroid::protobuf::bridge::Intent& ApplicationListUpdateEvent_Application::launch_intent() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.ApplicationListUpdateEvent.Application.launch_intent)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return launch_intent_ != NULL ? *launch_intent_ : *default_instance().launch_intent_;
#else
  return launch_intent_ != NULL ? *launch_intent_ : *default_instance_->launch_intent_;
#endif
}
inline ::kydroid::protobuf::bridge::Intent* ApplicationListUpdateEvent_Application::mutable_launch_intent() {
  set_has_launch_intent();
  if (launch_intent_ == NULL) launch_intent_ = new ::kydroid::protobuf::bridge::Intent;
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.ApplicationListUpdateEvent.Application.launch_intent)
  return launch_intent_;
}
inline ::kydroid::protobuf::bridge::Intent* ApplicationListUpdateEvent_Application::release_launch_intent() {
  clear_has_launch_intent();
  ::kydroid::protobuf::bridge::Intent* temp = launch_intent_;
  launch_intent_ = NULL;
  return temp;
}
inline void ApplicationListUpdateEvent_Application::set_allocated_launch_intent(::kydroid::protobuf::bridge::Intent* launch_intent) {
  delete launch_intent_;
  launch_intent_ = launch_intent;
  if (launch_intent) {
    set_has_launch_intent();
  } else {
    clear_has_launch_intent();
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.ApplicationListUpdateEvent.Application.launch_intent)
}

// -------------------------------------------------------------------

// ApplicationListUpdateEvent

// repeated .kydroid.protobuf.bridge.ApplicationListUpdateEvent.Application applications = 1;
inline int ApplicationListUpdateEvent::applications_size() const {
  return applications_.size();
}
inline void ApplicationListUpdateEvent::clear_applications() {
  applications_.Clear();
}
inline const ::kydroid::protobuf::bridge::ApplicationListUpdateEvent_Application& ApplicationListUpdateEvent::applications(int index) const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.ApplicationListUpdateEvent.applications)
  return applications_.Get(index);
}
inline ::kydroid::protobuf::bridge::ApplicationListUpdateEvent_Application* ApplicationListUpdateEvent::mutable_applications(int index) {
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.ApplicationListUpdateEvent.applications)
  return applications_.Mutable(index);
}
inline ::kydroid::protobuf::bridge::ApplicationListUpdateEvent_Application* ApplicationListUpdateEvent::add_applications() {
  // @@protoc_insertion_point(field_add:kydroid.protobuf.bridge.ApplicationListUpdateEvent.applications)
  return applications_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kydroid::protobuf::bridge::ApplicationListUpdateEvent_Application >&
ApplicationListUpdateEvent::applications() const {
  // @@protoc_insertion_point(field_list:kydroid.protobuf.bridge.ApplicationListUpdateEvent.applications)
  return applications_;
}
inline ::google::protobuf::RepeatedPtrField< ::kydroid::protobuf::bridge::ApplicationListUpdateEvent_Application >*
ApplicationListUpdateEvent::mutable_applications() {
  // @@protoc_insertion_point(field_mutable_list:kydroid.protobuf.bridge.ApplicationListUpdateEvent.applications)
  return &applications_;
}

// repeated .kydroid.protobuf.bridge.ApplicationListUpdateEvent.Application removed_applications = 2;
inline int ApplicationListUpdateEvent::removed_applications_size() const {
  return removed_applications_.size();
}
inline void ApplicationListUpdateEvent::clear_removed_applications() {
  removed_applications_.Clear();
}
inline const ::kydroid::protobuf::bridge::ApplicationListUpdateEvent_Application& ApplicationListUpdateEvent::removed_applications(int index) const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.ApplicationListUpdateEvent.removed_applications)
  return removed_applications_.Get(index);
}
inline ::kydroid::protobuf::bridge::ApplicationListUpdateEvent_Application* ApplicationListUpdateEvent::mutable_removed_applications(int index) {
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.ApplicationListUpdateEvent.removed_applications)
  return removed_applications_.Mutable(index);
}
inline ::kydroid::protobuf::bridge::ApplicationListUpdateEvent_Application* ApplicationListUpdateEvent::add_removed_applications() {
  // @@protoc_insertion_point(field_add:kydroid.protobuf.bridge.ApplicationListUpdateEvent.removed_applications)
  return removed_applications_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kydroid::protobuf::bridge::ApplicationListUpdateEvent_Application >&
ApplicationListUpdateEvent::removed_applications() const {
  // @@protoc_insertion_point(field_list:kydroid.protobuf.bridge.ApplicationListUpdateEvent.removed_applications)
  return removed_applications_;
}
inline ::google::protobuf::RepeatedPtrField< ::kydroid::protobuf::bridge::ApplicationListUpdateEvent_Application >*
ApplicationListUpdateEvent::mutable_removed_applications() {
  // @@protoc_insertion_point(field_mutable_list:kydroid.protobuf.bridge.ApplicationListUpdateEvent.removed_applications)
  return &removed_applications_;
}

// -------------------------------------------------------------------

// EventSequence

// optional .kydroid.protobuf.bridge.BootFinishedEvent boot_finished = 1;
inline bool EventSequence::has_boot_finished() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventSequence::set_has_boot_finished() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EventSequence::clear_has_boot_finished() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EventSequence::clear_boot_finished() {
  if (boot_finished_ != NULL) boot_finished_->::kydroid::protobuf::bridge::BootFinishedEvent::Clear();
  clear_has_boot_finished();
}
inline const ::kydroid::protobuf::bridge::BootFinishedEvent& EventSequence::boot_finished() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.EventSequence.boot_finished)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return boot_finished_ != NULL ? *boot_finished_ : *default_instance().boot_finished_;
#else
  return boot_finished_ != NULL ? *boot_finished_ : *default_instance_->boot_finished_;
#endif
}
inline ::kydroid::protobuf::bridge::BootFinishedEvent* EventSequence::mutable_boot_finished() {
  set_has_boot_finished();
  if (boot_finished_ == NULL) boot_finished_ = new ::kydroid::protobuf::bridge::BootFinishedEvent;
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.EventSequence.boot_finished)
  return boot_finished_;
}
inline ::kydroid::protobuf::bridge::BootFinishedEvent* EventSequence::release_boot_finished() {
  clear_has_boot_finished();
  ::kydroid::protobuf::bridge::BootFinishedEvent* temp = boot_finished_;
  boot_finished_ = NULL;
  return temp;
}
inline void EventSequence::set_allocated_boot_finished(::kydroid::protobuf::bridge::BootFinishedEvent* boot_finished) {
  delete boot_finished_;
  boot_finished_ = boot_finished;
  if (boot_finished) {
    set_has_boot_finished();
  } else {
    clear_has_boot_finished();
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.EventSequence.boot_finished)
}

// optional .kydroid.protobuf.bridge.WindowStateUpdateEvent window_state_update = 2;
inline bool EventSequence::has_window_state_update() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EventSequence::set_has_window_state_update() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EventSequence::clear_has_window_state_update() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EventSequence::clear_window_state_update() {
  if (window_state_update_ != NULL) window_state_update_->::kydroid::protobuf::bridge::WindowStateUpdateEvent::Clear();
  clear_has_window_state_update();
}
inline const ::kydroid::protobuf::bridge::WindowStateUpdateEvent& EventSequence::window_state_update() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.EventSequence.window_state_update)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return window_state_update_ != NULL ? *window_state_update_ : *default_instance().window_state_update_;
#else
  return window_state_update_ != NULL ? *window_state_update_ : *default_instance_->window_state_update_;
#endif
}
inline ::kydroid::protobuf::bridge::WindowStateUpdateEvent* EventSequence::mutable_window_state_update() {
  set_has_window_state_update();
  if (window_state_update_ == NULL) window_state_update_ = new ::kydroid::protobuf::bridge::WindowStateUpdateEvent;
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.EventSequence.window_state_update)
  return window_state_update_;
}
inline ::kydroid::protobuf::bridge::WindowStateUpdateEvent* EventSequence::release_window_state_update() {
  clear_has_window_state_update();
  ::kydroid::protobuf::bridge::WindowStateUpdateEvent* temp = window_state_update_;
  window_state_update_ = NULL;
  return temp;
}
inline void EventSequence::set_allocated_window_state_update(::kydroid::protobuf::bridge::WindowStateUpdateEvent* window_state_update) {
  delete window_state_update_;
  window_state_update_ = window_state_update;
  if (window_state_update) {
    set_has_window_state_update();
  } else {
    clear_has_window_state_update();
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.EventSequence.window_state_update)
}

// optional .kydroid.protobuf.bridge.ApplicationListUpdateEvent application_list_update = 3;
inline bool EventSequence::has_application_list_update() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EventSequence::set_has_application_list_update() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EventSequence::clear_has_application_list_update() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EventSequence::clear_application_list_update() {
  if (application_list_update_ != NULL) application_list_update_->::kydroid::protobuf::bridge::ApplicationListUpdateEvent::Clear();
  clear_has_application_list_update();
}
inline const ::kydroid::protobuf::bridge::ApplicationListUpdateEvent& EventSequence::application_list_update() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.EventSequence.application_list_update)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return application_list_update_ != NULL ? *application_list_update_ : *default_instance().application_list_update_;
#else
  return application_list_update_ != NULL ? *application_list_update_ : *default_instance_->application_list_update_;
#endif
}
inline ::kydroid::protobuf::bridge::ApplicationListUpdateEvent* EventSequence::mutable_application_list_update() {
  set_has_application_list_update();
  if (application_list_update_ == NULL) application_list_update_ = new ::kydroid::protobuf::bridge::ApplicationListUpdateEvent;
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.EventSequence.application_list_update)
  return application_list_update_;
}
inline ::kydroid::protobuf::bridge::ApplicationListUpdateEvent* EventSequence::release_application_list_update() {
  clear_has_application_list_update();
  ::kydroid::protobuf::bridge::ApplicationListUpdateEvent* temp = application_list_update_;
  application_list_update_ = NULL;
  return temp;
}
inline void EventSequence::set_allocated_application_list_update(::kydroid::protobuf::bridge::ApplicationListUpdateEvent* application_list_update) {
  delete application_list_update_;
  application_list_update_ = application_list_update;
  if (application_list_update) {
    set_has_application_list_update();
  } else {
    clear_has_application_list_update();
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.EventSequence.application_list_update)
}

// optional string error = 127;
inline bool EventSequence::has_error() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EventSequence::set_has_error() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EventSequence::clear_has_error() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EventSequence::clear_error() {
  if (error_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& EventSequence::error() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.EventSequence.error)
  return *error_;
}
inline void EventSequence::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(value);
  // @@protoc_insertion_point(field_set:kydroid.protobuf.bridge.EventSequence.error)
}
inline void EventSequence::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(value);
  // @@protoc_insertion_point(field_set_char:kydroid.protobuf.bridge.EventSequence.error)
}
inline void EventSequence::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kydroid.protobuf.bridge.EventSequence.error)
}
inline ::std::string* EventSequence::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.EventSequence.error)
  return error_;
}
inline ::std::string* EventSequence::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EventSequence::set_allocated_error(::std::string* error) {
  if (error_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete error_;
  }
  if (error) {
    set_has_error();
    error_ = error;
  } else {
    clear_has_error();
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.EventSequence.error)
}

// optional .kydroid.protobuf.bridge.StructuredError structured_error = 128;
inline bool EventSequence::has_structured_error() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EventSequence::set_has_structured_error() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EventSequence::clear_has_structured_error() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EventSequence::clear_structured_error() {
  if (structured_error_ != NULL) structured_error_->::kydroid::protobuf::bridge::StructuredError::Clear();
  clear_has_structured_error();
}
inline const ::kydroid::protobuf::bridge::StructuredError& EventSequence::structured_error() const {
  // @@protoc_insertion_point(field_get:kydroid.protobuf.bridge.EventSequence.structured_error)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return structured_error_ != NULL ? *structured_error_ : *default_instance().structured_error_;
#else
  return structured_error_ != NULL ? *structured_error_ : *default_instance_->structured_error_;
#endif
}
inline ::kydroid::protobuf::bridge::StructuredError* EventSequence::mutable_structured_error() {
  set_has_structured_error();
  if (structured_error_ == NULL) structured_error_ = new ::kydroid::protobuf::bridge::StructuredError;
  // @@protoc_insertion_point(field_mutable:kydroid.protobuf.bridge.EventSequence.structured_error)
  return structured_error_;
}
inline ::kydroid::protobuf::bridge::StructuredError* EventSequence::release_structured_error() {
  clear_has_structured_error();
  ::kydroid::protobuf::bridge::StructuredError* temp = structured_error_;
  structured_error_ = NULL;
  return temp;
}
inline void EventSequence::set_allocated_structured_error(::kydroid::protobuf::bridge::StructuredError* structured_error) {
  delete structured_error_;
  structured_error_ = structured_error;
  if (structured_error) {
    set_has_structured_error();
  } else {
    clear_has_structured_error();
  }
  // @@protoc_insertion_point(field_set_allocated:kydroid.protobuf.bridge.EventSequence.structured_error)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace bridge
}  // namespace protobuf
}  // namespace kydroid

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_kydroid_5fbridge_2eproto__INCLUDED
